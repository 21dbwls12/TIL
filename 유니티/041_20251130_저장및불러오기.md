# 데이터 저장 기능

게임의 진행 현황(한 번에 끝나지 않는 게임), 사운드 볼륨 등을 저장할 때 유용

## 승리 횟수 저장

__승리 횟수를 저장할__ 변수
- 싱글톤 패턴 사용
  - StartScene과 PlayScene 모두 필요
 
StartScene에 빈 오브젝트 추가(DataManager) &rarr; 새로운 DataManager 스크립트 생성 후 DataManager 오브젝트의 컴포넌트로 추가|
|:---:|
<img width="759" height="267" alt="스크린샷 2025-11-30 오후 8 27 02" src="https://github.com/user-attachments/assets/1430c695-c52b-4076-b88b-90a3bd840479" />|

DataManager 스크립트|
|:---:|

```C#
using UnityEngine;

public class DataManager : MonoBehaviour
{
    private int winCount;
    //프로퍼티
    public int WinCount
    {
        // WinCount 프로퍼티를 가져가려고 하면 winCount 변수 제공
        get { return winCount; }

        // WinCount 프로퍼티에 값을 할당하면 winCount 변수에 할당
        set
        {
            winCount = value;
            // 저장
            PlayerPrefs.SetInt("WinCount", winCount);
            // 물리적인 위치에 저장
            PlayerPrefs.Save();
        }
    }

    // 누구나 접근할 수 있는 DataManager의 인스턴스
    public static DataManager instance;

    private void Awake()
    {
        // 인스턴스가 비어있다면
        if (instance == null)
        {
            // 자기 자신 할당
            instance = this;

            // 씬 전환 시 삭제되지 않도록 유지
            DontDestroyOnLoad(gameObject);
        }

        // 인스턴스가 채워져있지만, 자기 자신과 다르다면
        else if (instance != this)
        {
            // 자기 자신의 오브젝트 삭제
            Destroy(gameObject);
        }
    }
}
```

__프로퍼티__
- `get`, `set`을 통해 변수의 읽기, 쓰기를 안전하게 관리 가능
- 변수를 읽거나 쓸 때마다 원하는 기능을 함께 처리 가능
- 프로퍼티 기본선언 형식
  - ```C#
    class 클래스명
    {
      데이터타입 필드명;
      접근한정자 데이터타입 프로퍼티명
      {
          get
          {
              return 필드명;
          }
          set
          {
              필드명 = value;
          }
      }
    }
    ```
- get
  - 속성 읽기
  - 없으면 쓰기 전용
- set / init
  - set이 없으면 읽기 전용

PlayerHP 스크립트|
|:---:|

```C#
...

public IEnumerator Ending(string result)
{
...

    (*)// 승리했다면 승리 횟수 증가
    (*)if (result == "승리") DataManager.instance.WinCount++;
}
```

<br>

# 불러오기 기능

## 불러온 데이터 출력 UI

StartScene 하위 Canvas &rarr; ConnectInfoTxt 복제(WinCountTxt)|
|:---:|
<img width="759" height="494" alt="스크린샷 2025-11-30 오후 9 18 52" src="https://github.com/user-attachments/assets/17e9ec9d-3671-4444-b645-975bbf5e527a" />|

<br>

## 코드 수정

WinCountTxt 오브젝트는 StartScene에만 존재

승리 횟수 변수를 가지고 있는 DataManager 스크립트는 씬이 전환될 때 유지되는 오브젝트에 존재

이 상태에서 만약 DataManager 스크립트에 WinCountTxt 오브젝트에 승리횟수를 출력하는 코드가 작성된다면

&rarr; 오류 발생 (씬이 전환되면서 WinCountTxt가 사라지기 때문)

Server 스크립트|
|:---:|

```C#
using Photon.Pun;
using Photon.Realtime;
using UnityEngine;
using UnityEngine.UI;

// 포톤 관련 콜백 함수를 상속받기 위함
public class Server : MonoBehaviourPunCallbacks
{
    // 시작 버튼
    public Button startBin;
    // 로비 화면
    public GameObject lobby;
    // 연결 현황 텍스트
    public Text connectInfoTxt;
    (*)// 승리 횟수 텍스트
    (*)public Text winCountTxt;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 시작 버튼의 OnClick() 함수에 OnClickStart() 함수 연결
        startBin.onClick.AddListener(OnClickStart);

        // 시작 버튼 비활성화 상태로 시작
        startBin.interactable = false;

        // 서버 접속 시도
        PhotonNetwork.ConnectUsingSettings();
        connectInfoTxt.text = "서버 접속 중...";

        (*)// 승리 횟수 출력
        (*)winCountTxt.text = "승리 횟수 : " + DataManager.instance.WinCount.ToString();
    }

    // 시작 버튼 누르면 호출
    void OnClickStart()
    {
        // 클릭 효과음 재생
        AudioManager.instance.Audio_Click(0);

        // 로비 접속 시도
        PhotonNetwork.JoinLobby();
        connectInfoTxt.text = "로비 접속 중...";
    }

    // 서버 접속에 성공하면 호출
    public override void OnConnectedToMaster()
    {
        // 시작 버튼 활성화
        startBin.interactable = true;
        connectInfoTxt.text = "서버 접속 성공!";
    }

    // 로비 접속에 성공하면 호출
    public override void OnJoinedLobby()
    {
        // 로비 화면으로 전환
        gameObject.SetActive(false);
        lobby.SetActive(true);
        connectInfoTxt.text = "로비 접속 성공!";
    }

    // 접속에 실패하면 호출
    public override void OnDisconnected(DisconnectCause cause)
    {
        // 서버 재접속 시도
        PhotonNetwork.ConnectUsingSettings();
        connectInfoTxt.text = "접속 실패, 서버 재접속 중...";
    }
}
```

DataManager 스크립트|
|:---:|

```C#
using UnityEngine;

public class DataManager : MonoBehaviour
{
    private int winCount;
    //프로퍼티 (메서드)
    public int WinCount
    {
        // WinCount 프로퍼티를 가져가려고 하면 winCount 변수 제공
        get
        {
            (*)// 승리 횟수를 출력하기 위해 저장되어 있던 데이터 불러오기
            (*)// 불러오기
            (*)winCount = PlayerPrefs.GetInt("WinCount");
            return winCount;
        }

        // WinCount 프로퍼티에 값을 할당하면 winCount 변수에 할당
        set
        {
            // value == 매개변수
            winCount = value;
            // 유니티에서 제공하는 클래스 (PlayerPrefs)
            // SetInt(),SetFloat(), SetString()
            // 저장
            PlayerPrefs.SetInt("WinCount", winCount);
            // 물리적인 위치에 저장
            PlayerPrefs.Save();
        }
    }

    // 누구나 접근할 수 있는 DataManager의 인스턴스
    public static DataManager instance;

    private void Awake()
    {
        // 인스턴스가 비어있다면
        if (instance == null)
        {
            // 자기 자신 할당
            instance = this;

            // 씬 전환 시 삭제되지 않도록 유지
            DontDestroyOnLoad(gameObject);
        }

        // 인스턴스가 채워져있지만, 자기 자신과 다르다면
        else if (instance != this)
        {
            // 자기 자신의 오브젝트 삭제
            Destroy(gameObject);
        }
    }
}
```

SetInt(), SetFloat(). SetString() 함수를 통해 저장할 때 첫 번째 인수로 지정했던 저장될 값의 이름을

GetInt(), GetFloat(), GetString() 함수를 호출하여 인수로 지정하면 해당 이름으로 저장되어 있던 값을 반환

    PlayerPrefs.SetInt("WinCount", winCount); 중 앞에 ""안에 들어있는 값

저장된 값이 없고 기본 반환값을 설정하고 싶다면 두 번째 인수로 지정

StartScene 하위 Canvas &rarr; Server 오브젝트 &rarr; Server 스크립트 컴포넌트의 Win Count Txt 변수에 값 추가(WinCountTxt 오브젝트)|
|:---:|
<img width="760" height="422" alt="스크린샷 2025-11-30 오후 9 41 27" src="https://github.com/user-attachments/assets/87e5e290-dd3c-4c15-b326-d5c9f1fcd431" />|

- 저장된 값을 삭제하려면 `PlayerPrefs.DeleteAll()` 함수(전체) 또는 `PlayerPrefs.DeleteKey()` 함수(특정 값) 호출
- 현재는 winCount 변수를 읽을 때마다 저장하고 있는데 불필요한 상황에서 실행될 수도 있음
  - 게임 종료 시 또는 저장하기 버튼을 누를 때 저장
  - 게임이 시작될 때 불러오기
  - 위와 같이 작성하는 것이 좋음(명확한 시점)

<br>
 
# JSON 사용

PlayerPrefs 클래스의 함수의 단점
- 배열이나 리스트는 저장 불가(자료형의 한계)
- 변수의 개수가 많아지면 관리가 어려움

&rarr; 다른 저장 방법: JSON(자바스크립트 객체 노테이션, JavaScript Object Notation) 이용

DataMangerTest 스크립트(새로운 스크립트 생성)|
|:---:|

```C#
// 로컬 위치에 파일을 저장하기 위해 파일 입출력을 담당하는 File 클래스 필요
using System.IO;
using UnityEngine;

// 직렬화
[System.Serializable]
// 저장용 클래스
public class Data
{
    public float hp;
    public string nickname;
    public bool[] isLevelOpen = new bool[5];
}

public class DataManagerTest : MonoBehaviour
{
    // 저장용 클래스의 인스턴스
    public Data data;

    // 저장 경로
    string path;

    // 싱글톤
    public static DataManagerTest instance;
    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
        }

        else if (instance != this)
        {
            Destroy(gameObject);
        }

        // 기기마다 폴더의 종류와 이름이 달라 임의로 경로를 작성하면 에러 발생 가능
        // Application.persistentDataPath -> 게임 실행 시 자동으로 생성되는 폴더 경로라서 안전
        // 저장 경로 설정
        path = Application.persistentDataPath + "/Data.json";
    }

    // 저장
    public void Save()
    {
        // JsonUtility -> 유니티에서 자체적으로 지원하는 JSON 모듈
        // JsonUtility.ToJson() -> 클래스를 JSON 파일에 담을 수 있는 문자열로 변환하는 함수
        // 저장용 클래스를 Json 형식(문자열)으로 변환
        string saveData = JsonUtility.ToJson(data, true);

        // 파일로 저장
        File.WriteAllText(path, saveData);

        print("저장하기 완료");
    }

    // 불러오기
    public void Load()
    {
        // File.Exists -> 인수로 지정한 경로에 파일이 있는지 확인하는 함수
        // 저장된 파일이 있다면
        if (File.Exists(path))
        {
            // 저장된 파일 읽어오기
            string loadData = File.ReadAllText(path);

            // JsonUtility.FromJson() -> JSON 파일에 작성된 문자열을 원하는 타입으로 전환하는 함수
            // JSON 형식(문자열)으로 저장된 파일을 Data 클래스 형태로 변환
            data = JsonUtility.FromJson<Data>(loadData);

            print("불러오기 완료");
        }
        else
        {
            print("저장된 파일 없음");
        }
    }
}
```

JSON 사용하면 클래스 전체를 저장할 수 있음(직렬화 필요)
- 직렬화
  - 클래스를 데이터, 파일, 메모리 등으로 저장하거나 전송하기 위해 바이트 타입으로 변화하는 것
  - 클래스 위에 `[System Serializable]` 작성

## 호출하기

연습용으로 구현중이므로 DataManagerTest 스크립트에서 호출
- 다른 클래스에서도 쉽게 접근 가능(싱글톤 패턴)

DataManagerTest 스크립트|
|:---:|

```C#
// 로컬 위치에 파일을 저장하기 위해 파일 입출력을 담당하는 File 클래스 필요
using System.IO;
using UnityEngine;

// 직렬화
[System.Serializable]
// 저장용 클래스
public class Data
{
    public float hp;
    public string nickname;
    public bool[] isLevelOpen = new bool[5];
}

public class DataManagerTest : MonoBehaviour
{
    // 저장용 클래스의 인스턴스
    public Data data;

    // 저장 경로
    string path;

    // 싱글톤
    public static DataManagerTest instance;
    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
        }

        else if (instance != this)
        {
            Destroy(gameObject);
        }

        // 기기마다 폴더의 종류와 이름이 달라 임의로 경로를 작성하면 에러 발생 가능
        // Application.persistentDataPath -> 게임 실행 시 자동으로 생성되는 폴더 경로라서 안전
        // 저장 경로 설정
        path = Application.persistentDataPath + "/Data.json";

        (*)// 불러오기
        (*)DataManagerTest.instance.Load();
    }

    (*)private void Update()
    (*){
        (*)// 우클릭하면
        (*)if (Input.GetMouseButtonDown(1))
        (*){
            (*)// 저장
            (*)DataManagerTest.instance.Save();
        (*)}
    (*)}

    // 저장
    public void Save()
    {
        // JsonUtility -> 유니티에서 자체적으로 지원하는 JSON 모듈
        // JsonUtility.ToJson() -> 클래스를 JSON 파일에 담을 수 있는 문자열로 변환하는 함수
        // 저장용 클래스를 Json 형식(문자열)으로 변환
        string saveData = JsonUtility.ToJson(data, true);

        // 파일로 저장
        File.WriteAllText(path, saveData);

        print("저장하기 완료");
    }

    // 불러오기
    public void Load()
    {
        // File.Exists -> 인수로 지정한 경로에 파일이 있는지 확인하는 함수
        // 저장된 파일이 있다면
        if (File.Exists(path))
        {
            // 저장된 파일 읽어오기
            string loadData = File.ReadAllText(path);

            // JsonUtility.FromJson() -> JSON 파일에 작성된 문자열을 원하는 타입으로 전환하는 함수
            // JSON 형식(문자열)으로 저장된 파일을 Data 클래스 형태로 변환
            data = JsonUtility.FromJson<Data>(loadData);

            print("불러오기 완료");
        }
        else
        {
            print("저장된 파일 없음");
        }
    }
}
```

게임 실행|<img width="759" height="620" alt="스크린샷 2025-11-30 오후 11 11 33" src="https://github.com/user-attachments/assets/c8cb6772-893e-42a6-b940-00d8e0f665b6" />
|:---:|:---:|
변수 값 입력 후 우클릭|<img width="758" height="665" alt="스크린샷 2025-11-30 오후 11 13 11" src="https://github.com/user-attachments/assets/1325d021-ff84-41a8-a8d1-8e3558f25e92" />
게임 재실행|<img width="761" height="620" alt="스크린샷 2025-11-30 오후 11 14 00" src="https://github.com/user-attachments/assets/4d2ad3a3-5734-4f03-9db6-3b0386ccc92d" />
