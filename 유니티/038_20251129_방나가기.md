# 방 나가기 기능 구현

엔딩 화면이 나타난 후에 키보드 또는 마우스의 어떤 버튼이든 입력되면 방에서 퇴장하는 기능 추가

PlaySceneManager 스크립트|
|:---:|

```C#
using System.Collections;
using Photon.Pun;
using UnityEngine;

(*)// 포톤 관련 콜백 함수를 상속받기 위함
(*)public class PlaySceneManager : MonoBehaviourPunCallbacks
{
    // 플레이어 스폰 위치
    public Transform[] playerSpawnPoints;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 현재 방에 참여한 플레이어 인원
        int playerCount = PhotonNetwork.CurrentRoom.PlayerCount;

        // 플레이어 인원에 따라 다른 스폰 위치에 플레잉어 생성(1명이면 0번, 2명이면 1번)
        // 프리팹을 복제하여 생성함과 동시에 네트워크에서 동기화
        // 항상 Resources 폴더를 경로로 사용하므로 Player 오브젝트를 프리팹화할 때 Prefabs 폴더가 아닌 Resources 폴더에 넣었던 것
        // 복제할 오브젝트에 PhotonView 컴포넌트가 부여되어 있어야 함(동기화 담당 및 고유 ID 배정)
        PhotonNetwork.Instantiate("Player", playerSpawnPoints[playerCount - 1].position, Quaternion.identity);
    }

    (*)// 코루틴 함수 + while문 또는 for문 + yield return null
    (*)// Update() 함수 사용하지 않아도 매 프레임마다 코드가 실행되도록 반복 가능, 원할 때 종료 가능 
    (*)// 스킬의 쿨타임과 같은 기능을 구현할 때 주로 사용
    (*)// 엔딩 이후로 실행될 기능들
    (*)public IEnumerator AfterEnding()
    (*){
        (*)// 방에 접속되어 있을 때 PhotonNetwork.InRoom 변수는 true로 설정되어 있음
        (*)// 그래서 이 조건을 달아서 반복문 실행
        (*)// 방에서 나가기 전까지 반복
        (*)while (PhotonNetwork.InRoom)
        (*){
            (*)// 아무 키나 입력되었다면
            (*)if (Input.anyKeyDown)
            (*){
                (*)// 방에서 퇴장 시도
                (*)PhotonNetwork.LeaveRoom();

                (*)// 반복문을 끝내서 함수 탈출
                (*)break;
            (*)}
        (*)}

        (*)// 다음 프레임까지 쉬기
        (*)yield return null;
    (*)}

    (*)// 방 퇴장에 성공하면 호출
    (*)public override void OnLeftRoom()
    (*){
        (*)// 1. StartScene 라는 이름의 씬 불러오기 (씬 전환)
        (*)PhotonNetwork.LoadLevel("1_StartScene");

        (*)// 마우스 커서 보이게
        (*)Cursor.visible = true;

        (*)// 마우스 커서가 움직일 수 있도록 잠금 해제
        (*)Cursor.lockState = CursorLockMode.None;
    (*)}
}
```

PlayerHp 스크립트|
|:---:|

```C#
using System.Collections;
using Photon.Pun;
using UnityEngine;
using UnityEngine.UI;

public class PlayerHP : MonoBehaviour
{
    // 플레이어의 체력
    public float hp = 100;
    // 플레이어의 체력바 (머리 위)
    public Slider hpBar_World;

    // 플레이어의 Animator 컴포넌트
    Animator anim;
    // 플레이어의 PhotonView 컴포넌트
    PhotonView pv;
    // 플레이어의 체력바 (화면)
    Slider hpBar_Screen;
    // Canvas 오브젝트
    Transform canvas;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        anim = GetComponent<Animator>();
        pv = GetComponent<PhotonView>();

        // 내 캐릭터일 때만 실행
        if (pv.IsMine)
        {
            // Canvas 검색해서 가져오기
            canvas = GameObject.Find("Canvas").transform;

            // Canvas의 부모를 나로 설정
            canvas.SetParent(transform);

            // 화면 왼쪽 상단에 있는 플레이어의 체력바 가져오기
            hpBar_Screen = canvas.GetComponentInChildren<Slider>();
        }
    }

    // Update is called once per frame
    public void Damaged(float damage, int hitter)
    {
        // 공격받았음을 RPC 통신으로 모두에게 전달
        // 공격한 사람의 정보 전달
        pv.RPC("RPC_Damgaged", RpcTarget.All, damage, hitter);
    }

    [PunRPC]
    void RPC_Damaged(float damage, int hitter)
    {
        // 공격 받은 데미지만큼 체력 감소
        hp -= damage;

        // 체력바에 체력 표시
        hpBar_World.value = hp;

        // 내 캐릭터일 때만 실행
        if (pv.IsMine)
        {
            // 화면 체력바에 체력 표시
            hpBar_Screen.value = hp;

            // 체력이 남아있다면
            if (hp > 0)
            {
                // 피격 애니메이션 실행
                anim.SetTrigger("damaged");
            }
            // 체력이 남아있지 않다면
            else
            {
                // 죽음 애니메이션 실행
                anim.SetTrigger("dead");

                // 플레이어 기능 중단
                GetComponentInChildren<CamerRotate>().enabled = false;

                // 패배 시 엔딩 기능 실행
                // 코루틴 함수 호출
                StartCoroutine(Ending("패배"));
            }
        }

        // 내 캐릭터가 아니어도 체력이 남아있지 않다면
        if (hp <= 0)
        {
            // 죽은 후에는 총에 맞지 않도록 태그 해제
            tag = "Untagged";

            // 플레이어의 기능 중단
            GetComponent<Player>().enabled = false;
            GetComponent<PlayerFire>().enabled = false;

            // 승리한 플레이어 찾아서 PlayerHp 컴포넌트 가져오기
            PlayerHP winner = PhotonNetwork.GetPhotonView(hitter).GetComponent<PlayerHP>();

            // 승리한 플레이어에게 승리시 엔딩 기능 실행
            StartCoroutine(winner.Ending("승리"));
        }
    }

    // 코루틴 함수
    // 코루틴 함수가 리턴하는 값은 IEnumerator 타입
    // 엔딩에서 실행될 기능들
    public IEnumerator Ending(string result)
    {
        // 내 캐릭터가 아니라면 함수 탈출하여 아래 코드 실행 불가
        if (!pv.IsMine) yield break;

        // yield return을 이용해 잠시 함수에서 벗어나 다른 작업을 하고 올 수 있음
        // 동시에 실행 X, 원하는 시간만큼 잠시 중단되었다가 재실행
        // 1초동안 아래 코드가 실행되지 않도록 쉬기
        yield return new WaitForSeconds(1f);

        // Canvas의 2번째 자식인 Ending 오브젝트 가져오기
        Transform ending = canvas.GetChild(2);

        // 결과 UI 출력
        ending.GetChild(0).GetComponent<Text>().text = "- " + result + " -";

        // 결과 화면 활성화
        ending.gameObject.SetActive(true);

        // 승리한 플레이어도 기능 실행 중단
        // 플레이어의 기능 중단
        GetComponent<Player>().enabled = false;
        GetComponent<PlayerFire>().enabled = false;
        GetComponentInChildren<CamerRotate>().enabled = false;

        (*)// PlaySceneManager 스크립트의 AfterEnding() 함수 호출 후 같은 클래스의 OnLeftRoom() 함수 호출
        (*)// 엔딩 이후의 기능 실행
        (*)StartCoroutine(FindAnyObjectByType<PlaySceneManager>().AfterEnding());
    }
}
```
