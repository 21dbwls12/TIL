# 물리 작용

## 점프 기능

- Spacebar 키를 누르면 점프하는 기능 추가
- 점프 후에 다시 중력에 의해 아래로 떨어지는 것 까지

1. [물리 작용을 담당하는 컴포넌트](#물리-작용-컴포넌트)
2. [착지할 바닥과 충돌 효과](#바닥-추가)
3. [Spacebar 키 입력 신호 감지](#점프-기능-구현)
4. [물리 작용을 활용한 점프 기능](#점프-기능-구현)
5. [점프 횟수 제한](#점프-횟수-제한)

<br>

### 물리 작용 컴포넌트

`Rigidbody` 사용(기본적인 물리 작용 기능을 가진 컴포넌트)

 <img width="416" height="333" alt="스크린샷 2025-09-29 오후 2 43 53" src="https://github.com/user-attachments/assets/88062d5e-eee2-4639-bc1b-d7eea090ab8b" />

- Mass &rarr; 질량(무게)
- Drag &rarr; 공기 저항
- Angular Drag &rarr; 회전 저항
- Use Gravity &rarr; 중력 적용 여부
- isKinematic &rarr; 외부 물리 작용 차단 여부
  - 선택하면 내부 코드를 이용한 물리 구현만 가능하고, 선택하지 않으면 외부적으로 작용하는 물리 구현까지 가능
- Collision Detection
  - Discrete &rarr; 불연속적으로 충돌 검사
  - Continuous&rarr; 연속적으로 충돌 검사
  - Continuous Speculative &rarr; 추측성 충돌 검사
- Contraints &rarr; 위치와 각도에 물리 구현 적용 여부

<br>
Rigidbody 추가하고 플레이시 해당 오브젝트가 바닥으로 떨어짐(Player 오브젝트를 지지하는 바닥이 없기 때문)

https://github.com/user-attachments/assets/a95ac747-e723-4704-988b-b5e58af5ac4e

### 바닥 추가

 - 3D object &rarr; plane

바닥 추가 후 플레이하면 플레이어 오브젝트가 넘어짐

https://github.com/user-attachments/assets/78ecc7b1-d70e-40c6-b214-33c1b9b46051

플레이어의 오브젝트 중 Rigidbody의 Freeze Rotation 활성화

<img width="416" height="335" alt="스크린샷 2025-09-29 오후 11 24 36" src="https://github.com/user-attachments/assets/b7f71f5f-a2af-4e12-bb8d-f6909d0082ac" />

#### 오브젝트가 충돌을 발생시켜 더 이상 떨어지지 않게 하기 위한 조건

- 두 오브젝트 모두 Colider 컴포넌트를 가지고 있어야 함
- 두 오브젝트 중 적어도 한 오브젝트는 Rigidbody 컴포넌트를 가지고 있어야 함

Player|Ground
|:---:|:---:|
<img width="168" height="22" alt="스크린샷 2025-09-29 오후 11 28 13" src="https://github.com/user-attachments/assets/b7934c09-d306-4b83-890d-8529a030d2f9" />|<img width="173" height="25" alt="스크린샷 2025-09-29 오후 11 28 27" src="https://github.com/user-attachments/assets/9f5ac13e-4d4b-4e1d-a092-399e240d1d6e" />

#### Colider 컴포넌트 속성

- isTrigger
  - 활성화 &rarr; 충돌 시 통과하지만 충돌은 감지 가능
  - 비활성화 &rarr; 충돌 시 통과하지 않고 작용반작용 발생
- (Physic) Material &rarr; 물리적인 재질
- Center &rarr; 위치 조절
- Radious &rarr; 반지름 길이 조절
- Height &rarr; 높이 길이 조절

### 점프 기능 구현

- Spacebar 키를 감지
- 점프 기능 구현

#### `AddForce()`

- 물리 작용을 이용해 힘을 발생시키는 함수
- (힘을 가할 방향과 크기를 담은 벡터, 힘의 방식(`ForceMode`))
- `Vector3.up` == `new Vector3(0, 1, 0)`
- `ForceMode`
  - `ForceMode.Impulse` &rarr; 무게를 적용하고, 순간적인 힘을 가함
  - `ForceMode.VelocityChange` &rarr; 무게를 무시하고, 순간적인 힘을 가함
  - `ForceMode.Force` &rarr; 무게를 적용하고, 연속적으로 힘을 가함
  - `ForceMode.Acceleration` &rarr; 무게를 무시하고, 연속적으로 힘을 가함

<br>

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        transform.position += dir * moveSpeed * Time.deltaTime;

        // Space 키를 누른 순간
        if (Input.GetKeyDown(KeyCode.Space))
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);
        }
    }
}
```

<img width="414" height="24" alt="스크린샷 2025-09-30 오후 9 03 37" src="https://github.com/user-attachments/assets/ef713747-203e-4c46-bc00-4a9dcf484845" />

https://github.com/user-attachments/assets/a44507c3-acf6-4152-9c2d-ad132eb9ccbb

### 점프 횟수 제한

- 현재는 점프를 계속 하면 계속 위로 올라감
- 2단 점프까지만 허용하도록 코드 수정
 - 조건 사용

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        transform.position += dir * moveSpeed * Time.deltaTime;

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }
    }
}
```

지금은 Spaceebar를 2번 누르면 더 이상 점프가 안됨

#### 충돌 정보 감지

- 바닥에 착지한 후 jumpCount를 리셋해야 함
 - 바닥 충돌 감지 필요

##### `OnCollision` 함수

- 두 오브젝트 모두 isTrigger가 체크되어 있지 않은 상황에서 충돌이 발생했을 때 호출되는 함수
  - `OnCollisionEnter()` &rarr; isTrigger가 비활성화일 때, 충돌이 발생한 순간 호출
  - `OnCollisionStay()` &rarr; isTrigger가 비활성화일 때, 충돌이 지속되는 동안 호출
    - 무한정 호출되지는 않고, 오브젝트에 변화가 없으면 어느 순간 호출이 중단되기 때문에 `Update()`함수와 같이 사용 권장
  - `OnCollisionExit()` &rarr; isTrigger가 비활성화일 때, 충돌이 끝나는 순간 호출
- 두 오브젝트 중 하나라도 isTrigger가 체크되어 있는 상황에서 충돌이 발생했을 때 호출되는 함수
  - `OnTriggerEnter()` &rarr; isTrigger가 활성화일 때, 충돌이 발생한 순간 호출
  - `OnTriggerStay()` &rarr; isTrigger가 활성화일 때, 충돌이 지속되는 동안 호출
    - 무한정 호출되지는 않고, 오브젝트에 변화가 없으면 어느 순간 호출이 중단되기 때문에 `Update()`함수와 같이 사용 권장
  - `OnTriggerExit()` &rarr; isTrigger가 활성화일 때, 충돌이 끝나는 순간 호출

isTrigger 솔성이 __비활성화__ 되어있고 바닥과 __충돌이 발생한 순간__ 의 정보를 사용

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        transform.position += dir * moveSpeed * Time.deltaTime;

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }
    }

    // 어떤 물체와 충돌을 시작한 순간에 호출
    private void OnCollisionEnter(Collision collision)
    {
        // 충돌한 물체의 태그가 "Ground"라면
        if (collision.gameObject.tag == "Ground")
        {
            // 점프 횟수 초기화
            jumpCount = 0;
        }
    }
}
```

https://github.com/user-attachments/assets/5c2072ba-62b4-449a-a10c-5444e2870806

### 물리 작용 적용

https://github.com/user-attachments/assets/0eb5ca30-42c6-4910-bab0-815f0c8f41e9

- Player 오브젝트가 물리 작용이 적용되었으니 벽에 부딪혔을 때 Rigidbody 컴포넌트는 더 이상 이동할 수 없다고 판단하지만 Transform 컴포넌트는 코드에 적힌 이동 기능에 의해 Position은 계속 변화하려고 함
- 벽에 부딪히면 비정상적인 떨림이 생김
- 충돌 방지 코드 수정 필요

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        // transform.position += dir * moveSpeed * Time.deltaTime;

        // 물리 작용을 이용해 이동
        rb.MovePosition(rb.position + (dir * moveSpeed * Time.deltaTime));

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }
    }

    // 어떤 물체와 충돌을 시작한 순간에 호출
    private void OnCollisionEnter(Collision collision)
    {
        // 충돌한 물체의 태그가 "Ground"라면
        if (collision.gameObject.tag == "Ground")
        {
            // 점프 횟수 초기화
            jumpCount = 0;
        }
    }
}
```



