# 다른 플레이어가 생성한 방에서 상태 동기화

## 참가자의 플레이어 캐릭터 생성

플레이어 캐릭터 생성될 위치 파악 &rarr; Create Empty(PlayerSpawnPoint)

플레이어의 위치 복사|<img width="747" height="366" alt="스크린샷 2025-10-20 오후 4 17 33" src="https://github.com/user-attachments/assets/160c40aa-0cc5-4309-8b98-834c081f1473" />
|:---:|:---:|
PlayerSpawnPoint에 붙여넣기|<img width="764" height="467" alt="스크린샷 2025-10-20 오후 4 18 37" src="https://github.com/user-attachments/assets/f5862d96-e3d0-4737-b2f3-6b19cb4efb2a" />
플레이어 두명이 겹치게 생성되지 않게 복제 후 x값 조절|<img width="168" height="34" alt="스크린샷 2025-10-20 오후 4 21 10" src="https://github.com/user-attachments/assets/5be3c5b7-1fab-469a-9adf-212f07afde22" />
플레이어 오브젝트 프리팹화(Prefabs 폴더 말고 Resources 폴더)|<img width="225" height="63" alt="스크린샷 2025-10-20 오후 4 24 39" src="https://github.com/user-attachments/assets/6a679ad8-2028-45b6-88a2-a5f78223a7b5" />

방에 참가한 플레이어 관리를 위한 오브젝트 생성
- Create Empty(PlaySceneManager) &rarr; PlaySceneManager 스크립트 컴포넌트로 추가

PlaySceneManager 스크립트|
|:---:|

```C#
using Photon.Pun;
using UnityEngine;

public class PlaySceneManager : MonoBehaviour
{
    // 플레이어 스폰 위치
    public Transform[] playerSpawnPoints;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 현재 방에 참여한 플레이어 인원
        int playerCount = PhotonNetwork.CurrentRoom.PlayerCount;

        // 플레이어 인원에 따라 다른 스폰 위치에 플레잉어 생성(1명이면 0번, 2명이면 1번)
        // 프리팹을 복제하여 생성함과 동시에 네트워크에서 동기화
        // 항상 Resources 폴더를 경로로 사용하므로 Player 오브젝트를 프리팹화할 때 Prefabs 폴더가 아닌 Resources 폴더에 넣었던 것
        // 복제할 오브젝트에 PhotonView 컴포넌트가 부여되어 있어야 함(동기화 담당 및 고유 ID 배정)
        PhotonNetwork.Instantiate("Player", playerSpawnPoints[playerCount - 1].position, Quaternion.identity);    
    }
}
```

<img width="502" height="144" alt="스크린샷 2025-10-20 오후 4 39 38" src="https://github.com/user-attachments/assets/9cb10160-f69d-4643-bbbc-e1e8249f727c" />|<img width="747" height="314" alt="스크린샷 2025-10-20 오후 4 40 07" src="https://github.com/user-attachments/assets/91f8c677-c582-4a7e-8eb1-79455ae90f3a" />
|:---:|:---:|

Player 스크립트|
|:---:|

```C#
// 플레이어가 생성되자마자 땅과 충돌해서 Start() 함수보다 OnCollisionEnter() 함수가 먼저 호출
// Start() -> Awake()(항상 제일 먼저 호출)
void Awake()
{
    // 플레이어의 Rigidbody, Animator 컴포넌트 가져와서 저장
    rb = GetComponent<Rigidbody>();
    anim = GetComponent<Animator>();
}
```

## 자신의 캐릭터만 제어

현재는 같은 스크립트로 모든 플레이어 오브젝트가 적용되기 때문에 플레이어 캐릭터 2개가 동시에 작동

각각의 컴퓨터에서 보이는 캐릭터가 2개씩 &rarr; 4개의 플레이어 오브젝트

※ 원래는 다른 창 두개로 접속해야 하는데 빌드가 제대로 안돼서 임시로 1개의 캐릭터만 사용해서 진행 예정

두 사용자가 접속한 상태에서 각각 두 캐릭터의 인스펙터창 &rarr; Photon View 컴포넌트 확인

플레이어 1|플레이어 2
|:---:|:---:|
<img width="465" height="109" alt="스크린샷 2025-11-26 오후 4 30 47" src="https://github.com/user-attachments/assets/79798ede-d2ed-4e87-a6c5-e2246267fee3" />|2001, True, 2, 2, 2

PhotonView.IsMine: 오브젝트가 실제 로컬에서 생성한 객체인지 다른 플레이어인지 구별 가능

Player 스크립트|
|:---:|

```C#
(*)using Photon.Pun;
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 회전 속도
    public float rotateSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;
    // 플레이어의 Animator 컴포넌트
    Animator anim;
    (*)// 플레이어의 PhotonView 컴포넌트
    (*)PhotonView pv;

    // 플레이어가 생성되자마자 땅과 충돌해서 Start() 함수보다 OnCollisionEnter() 함수가 먼저 호출
    // Start() -> Awake()(항상 제일 먼저 호출)
    void Awake()
    {
        (*)// 플레이어의 Rigidbody, Animator, PhotonView 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
        anim = GetComponent<Animator>();
        (*)pv = GetComponent<PhotonView>();
    }

    // Update is called once per frame
    void Update()
    {
        // 내 캐릭터가 아니라면 함수 탈출하여 아래 코드 실행 불가 
        if (!pv.IsMine) return;

        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // 플레이어를 기준으로 dir의 방향 조절
        dir = transform.TransformDirection(dir);

        // // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        // transform.position += dir * moveSpeed * Time.deltaTime;

        // 물리 작용을 이용해 이동
        rb.MovePosition(rb.position + (dir * moveSpeed * Time.deltaTime));

        // 이동하는 속도를 velocity 변수에 할당
        // magnitude == dir에 있는 벡터의 크기와 방향 중 벡터의 크기
        anim.SetFloat("velocity", dir.magnitude);

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프 애니메이션 실행
            anim.SetTrigger("jump");
            anim.SetBool("isJump", true);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }

        // 마우스의 좌우 움직임 입력을 숫자로 받아서 저장
        float mouseMoveX = Input.GetAxis("Mouse X");

        // 마우스가 움직인 만큼 Y축 회전
        transform.Rotate(0, mouseMoveX * rotateSpeed * Time.deltaTime, 0);
    }

    // 어떤 물체와 충돌을 시작한 순간에 호출
    private void OnCollisionEnter(Collision collision)
    {
        (*)// 충돌한 물체의 태그가 "Ground"이고, 내 캐릭터일 때만
        (*)if (collision.gameObject.tag == "Ground" && pv.IsMine)
        {
            // 점프 횟수 초기화
            jumpCount = 0;

            // 점프 애니메이션 종료
            anim.SetBool("isJump", false);
        }
    }
}
```

PlayerFire 스크립트|
|:---:|

```C#
(*)using Photon.Pun;
using UnityEngine;

public class PlayerFire : MonoBehaviour
{
    // // 총알 프리팹을 담아둘 변수
    // public GameObject bulletPref;

    // // 총알 발사하는 힘
    // public float firePower;

    // 총 효과 프리팹을 담아둘 변수
    public GameObject shootEffectPref;

    // 플레이어의 Animator 컴포넌트
    Animator anim;
    (*)// 플레이어의 Photon View 컴포넌트
    (*)PhotonView pv;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        anim = GetComponent<Animator>();
        (*)pv = GetComponent<PhotonView>();

        // 마우스 커서 안 보이게
        Cursor.visible = false;

        // 마우스 커서가 게임 화면을 벗어나지 못하도록 잠금
        Cursor.lockState = CursorLockMode.Confined;
    }

    // Update is called once per frame
    void Update()
    {
        (*)// 마우스 좌클릭을 누르는 순간, 내 캐릭터일 때만
        (*)if (Input.GetMouseButtonDown(0) && pv.IsMine)
        {
            // // // 게임 안에 리소스 폴더에서 불러오기한 총알 프리팹의 복사본 생성
            // // // 실수를 줄일 수 있고 편리하나 연산이 더 많이 발생
            // // // 꼭 필요한 경우에만 사용 권장
            // // Instantiate(Resources.Load("Bullet"));

            // // 게임 안에 총알 프리팹의 복사본 생성 (플레이어의 위치보다 1 앞에)
            // // forward -> z축 +1 (0,0,+1)
            // // Vector3.forward -> 절대적인 방향을 기준으로 (0,0,+1)
            // // transform.forward -> 오브젝트의 시선 방향을 기준으로 (0,0,+1)
            // // Quaternion.identity -> 모든 축으로의 회전 각도 0
            // // 생성 후 bullet 변수에 할당
            // GameObject bullet = Instantiate(bulletPref, transform.position + transform.forward, Quaternion.identity);

            // // 총알 복사본이 앞으로 날아가는 순간적인 힘 발생
            // bullet.GetComponent<Rigidbody>().AddForce(transform.forward * firePower, ForceMode.Impulse);

            // 총 쏘는 애니메이션 실행
            anim.SetTrigger("shoot");

            // 화면 가운데에서 시작하는 Ray 생성
            Ray ray = Camera.main.ViewportPointToRay(new Vector2(0.5f, 0.5f));

            // Ray에 맞은 물체를 담아둘 변수
            RaycastHit hit;

            // Ray를 발사하고, Ray에 맞은 물체는 hit에 저장
            // 맞은 물체가 있을 때만
            if (Physics.Raycast(ray, out hit))
            {
                // 맞은 위치에, 맞은 표면의 수직이 되는 각도로 총 효과 프리팹의 복사본 생성
                GameObject shootEffect = Instantiate(shootEffectPref, hit.point + hit.normal * 0.01f, Quaternion.LookRotation(hit.normal));

                // 총알 자국을 맞은 오브젝트의 자식으로 설정
                shootEffect.transform.SetParent(hit.transform);

                // Ray에 맞은 물체가 적이라면
                if (hit.transform.tag == "Enemy")
                {
                    // 적에게 10만큼 공격 받으라고 전달
                    hit.transform.SendMessage("Damaged", 10);
                }
            }
        }
    }
}
```

## 플레이어 캐릭터 내의 Main Camera 출력화면 설정

Player 오브젝트 하위의 Main Camera가 여러개가 되면서 생기는 문제

Player 오브젝트의 자식으로부터 분리하고 씬 내에서 Main Camera 오브젝트가 하나만 존재하도록 수정

Player 프리펩 하이러라키창에 추가|<img width="224" height="163" alt="스크린샷 2025-11-26 오후 5 53 01" src="https://github.com/user-attachments/assets/511a6a75-82b3-46e4-9aa3-4c60a52125f8" />
|:---:|:---:|
Player 프리펩 해제|<img width="640" height="420" alt="스크린샷 2025-11-26 오후 5 54 53" src="https://github.com/user-attachments/assets/86467217-2c87-4d67-82f1-3600d10fa4ea" />
Player 오브젝트 하위에서 Main Camera 해제|<img width="211" height="38" alt="스크린샷 2025-11-26 오후 5 57 41" src="https://github.com/user-attachments/assets/05244978-874a-473d-9277-100d7ccfed01" />

플레이어 캐릭터가 생성되는 순간 Main Camera를 자식으로 설정(코드 수정)

Player 스크립트|
|:---:|

```C#
// Awake() 함수 안 pv = GetComponent<PhotonView>(); 코드 아래에 추가

// 내 캐릭터일 때만 실행
if (pv.IsMine)
{
    // Main Camera 검색해서 가져오기
    Transform camera = Camera.main.transform;

    // Main Camera의 부모를 나로 설정
    camera.SetParent(transform);

    // 나를 기준으로 적당한 위치로 이동
    camera.localPosition = new Vector3(0, 1.2f, 0.4f);
}
```

실행 시 Main Camera Player 오브젝트 자식으로 설정됨|
|:---:|
<img width="194" height="116" alt="스크린샷 2025-11-26 오후 6 19 35" src="https://github.com/user-attachments/assets/d39ba24c-49b0-46e6-a3b5-874d47ce7ba9" />|

## 각 플레이어의 행동 동기화(컴포넌트 동기화)

다른 플레이어의 화면에서 현재 이동하고 공격하는 행동이 보이지 않음

Player 프리펩 &rarr; Photon Transform View, Photon Rigidbody View, Photon Animator View 컴포넌트 추가|
|:---:|
<img width="491" height="576" alt="스크린샷 2025-11-26 오후 6 53 06" src="https://github.com/user-attachments/assets/794684e1-3b44-4611-91aa-b1a8fceca07c" />|

Photon Transform View 컴포넌트|
|:---:|

<img width="487" height="155" alt="스크린샷 2025-11-26 오후 10 21 41" src="https://github.com/user-attachments/assets/2b304ccf-690b-4e88-9111-22ebd6dfdd21" />

- Position
  - 선택 시, Transform의 속성 중 위치 정보 동기화
- Rotation
  - 선택 시, Transform의 속성 중 각도 정보 동기화
- Scale
  - 선택 시, Transform의 속성 중 크기 정보 동기화
  - 크기가 변하는 게임은 아니므로 선택 X
- Use Local
  - 보통은 로컬 좌표(월드)를 기준으로 동기화
  - 선택 시, 부모를 기준으로 동기화
    - 현재는 Player 오브젝트가 부모를 가지지 않아서 무관 

Photon Rigdbody View 컴포넌트|
|:---:|

<img width="486" height="157" alt="스크린샷 2025-11-26 오후 10 36 24" src="https://github.com/user-attachments/assets/67cd247d-941a-40c1-8c9c-8bfafea9a78e" />

- Enable teleport for large distances  
  <img width="471" height="50" alt="스크린샷 2025-11-26 오후 10 40 14" src="https://github.com/user-attachments/assets/0648f1cd-22b1-4ab6-9f46-c663d9277a23" />
  - 선택 시, 해당 캐릭터가 3보다 먼 거리를 이동한 경우 텔레포트 하는 것을 허용하여 동기화하는 데 사용되는 자원을 줄이겠다는 의미
- Synchronize Velocity
  - 선택 시, 이동 속도 동기화
- Synchronize Angular Velocity
  - 선택 시, 회전 속도 동기화

Photon Animator View 컴포넌트|
|:---:|

<img width="490" height="266" alt="스크린샷 2025-11-26 오후 11 05 42" src="https://github.com/user-attachments/assets/841a846b-f807-4a9b-817f-829372b34b81" />
<img width="281" height="90" alt="스크린샷 2025-11-26 오후 11 06 00" src="https://github.com/user-attachments/assets/c4a259bb-ae9e-4405-a763-4108bf9e5338" />

- 모든 항목을 Discrete 또는 Continous로 설정해야 애니메이션 전환 동기화 가능
- Continous
  - Animator를 연속적으로 체크하여 장면을 자연스럽게 연출
  - 많은 자원 사용으로 인해 무거움

새로 추가한 3가지 Photon 컴포넌트 변경 후|
|:---:|
애니메이터 컨트롤러의 trigger 자료형 변수 때문에 표시되는 경고, 게임 실행에 문제 없음|
<img width="491" height="644" alt="스크린샷 2025-11-26 오후 11 25 40" src="https://github.com/user-attachments/assets/e67f22b2-a9ea-47f0-ab9a-09ed31dd45f0" />|
