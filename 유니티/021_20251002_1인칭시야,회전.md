# 1인칭 시야

1. [1인칭 시야의 카메라](카메라-배치)
2. [마우스 움직임 감지](캐릭터의-좌우-회전)
3. [시야를 상하좌우로 회전하는 기능](캐릭터의-좌우-회전)
4. [시야의 회전 제한](시야-회전-각도-제한)

<br>

## 카메라 배치

- 씬 화면에 있는 Main Camera 오브젝트 위치, 각도 조절
- Main Camera가 Player 오브젝크를 따라다닐 수 있도록 부모-자식 관계로 설정

<img width="426" height="94" alt="스크린샷 2025-10-02 오후 7 51 51" src="https://github.com/user-attachments/assets/f693ba93-1723-40d4-81c7-08afaaf67652" />|<img width="189" height="54" alt="스크린샷 2025-10-02 오후 7 56 57" src="https://github.com/user-attachments/assets/6fda0693-ee3c-47a0-bf1d-bd5deca9de8f" />
|:---:|:---:|
<img width="305" height="227" alt="스크린샷 2025-10-02 오후 7 52 00" src="https://github.com/user-attachments/assets/0b3c3867-df9c-4a19-9cd7-14d82ca06308" />|<img width="587" height="423" alt="스크린샷 2025-10-02 오후 7 52 42" src="https://github.com/user-attachments/assets/d9dd4d97-30a1-4404-9538-82d4117aa5a7" />

## 캐릭터의 좌우 회전

마우스 움직임을 감지해서 상하좌우 회전하는 코드 추가

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 회전 속도
    public float rotateSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        // transform.position += dir * moveSpeed * Time.deltaTime;

        // 물리 작용을 이용해 이동
        rb.MovePosition(rb.position + (dir * moveSpeed * Time.deltaTime));

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }

        // 마우스의 좌우 움직임 입력을 숫자로 받아서 저장
        float mouseMoveX = Input.GetAxis("Mouse X");

        // 마우스가 움직인 만큼 Y축 회전
        transform.Rotate(0, mouseMoveX * rotateSpeed * Time.deltaTime, 0);
    }

    // 어떤 물체와 충돌을 시작한 순간에 호출
    private void OnCollisionEnter(Collision collision)
    {
        // 충돌한 물체의 태그가 "Ground"라면
        if (collision.gameObject.tag == "Ground")
        {
            // 점프 횟수 초기화
            jumpCount = 0;
        }
    }
}
```

#### transform X축이 아닌 Y축을 건드는 이유

<img width="320" height="211" alt="image" src="https://github.com/user-attachments/assets/cc7f4834-f199-405f-88f3-cef037d4f3e0" />

<br>
<br>
<br>

<img width="415" height="110" alt="스크린샷 2025-10-02 오후 8 35 35" src="https://github.com/user-attachments/assets/d3782c90-9414-451a-9ad3-24541331f873" />

https://github.com/user-attachments/assets/ba031a12-edef-4de1-8344-f1570256dd87

🥅 바라보는 방향을 기준으로 움직이지 않고 방향키 기준으로 이동

<br>

### 바라보는 방향으로 이동

`dir = transform.TransformDirection(dir)`추가
- dir의 방향을 결정하는 기준을 Player 오브젝트가 바라보는 방향으로 변경하는 코드

```C#
using UnityEngine;

public class Player : MonoBehaviour
{
    // 이동 속도
    public float moveSpeed;
    // 회전 속도
    public float rotateSpeed;
    // 점프하는 힘
    public float jumpPower;

    // 점프환 횟수
    int jumpCount;

    // 플레이어의 Rigidbody 컴포넌트
    Rigidbody rb;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 플레이어의 Rigidbody 컴포넌트 가져와서 저장
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        // 방향키 또는 WASD키 입력을 숫자로 받아서 저장
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // x축에는 h의 값을, z축에는 v의 값을 넣은 변수 생성
        // dir -> direction
        Vector3 dir = new Vector3(h, 0, v);

        // 모든 방향의 속도가 동일하도록 정규화
        dir.Normalize();

        // 플레이어를 기준으로 dir의 방향 조절
        dir = transform.TransformDirection(dir);

        // // 이동할 방향에 원하는 속도 곱하기 (모든 기기에서 동일한 속도)
        // transform.position += dir * moveSpeed * Time.deltaTime;

        // 물리 작용을 이용해 이동
        rb.MovePosition(rb.position + (dir * moveSpeed * Time.deltaTime));

        // Space 키를 누른 순간, 점프한 횟수가 2회 미만이라면
        if (Input.GetKeyDown(KeyCode.Space) && jumpCount < 2)
        {
            // 위로 순간적인 힘 발생
            rb.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);

            // 점프할 때마다 점프 횟수 증가
            jumpCount++;
        }

        // 마우스의 좌우 움직임 입력을 숫자로 받아서 저장
        float mouseMoveX = Input.GetAxis("Mouse X");

        // 마우스가 움직인 만큼 Y축 회전
        transform.Rotate(0, mouseMoveX * rotateSpeed * Time.deltaTime, 0);
    }

    // 어떤 물체와 충돌을 시작한 순간에 호출
    private void OnCollisionEnter(Collision collision)
    {
        // 충돌한 물체의 태그가 "Ground"라면
        if (collision.gameObject.tag == "Ground")
        {
            // 점프 횟수 초기화
            jumpCount = 0;
        }
    }
}
```

https://github.com/user-attachments/assets/b6dfb850-f641-48c8-b698-8b93d48e6e98

### 시야의 상하회전

좌우 회전처럼 Player 오브젝트 자체를 위아래로 회전시키면 X축 방향으로 회전하면서 넘어지기 때문에 고개만 움직이는 것처럼 카메라만 회전

새 스크립트 생성(Camera Rotate) &rarr; Main Camera에 스크립트 컴포넌트 추가

```C#
using UnityEngine;

public class CamerRotate : MonoBehaviour
{
    //회전 속도
    public float rotateSpeed;

    // Update is called once per frame
    void Update()
    {
        // 마우스의 위아래 움직임 입력을 숫자로 받아서 저장
        float mouseMoveY = Input.GetAxis("Mouse Y");

        // 마우스가 움직인 만큼 X축 회전   
        // X축 값이 커질수록 아래로 회전 -> 마우스를 위로 움직이면 시야가 아래로 내려감 -> 음수로 설정
        transform.Rotate(-mouseMoveY * rotateSpeed * Time.deltaTime, 0, 0);     
    }
}
```

https://github.com/user-attachments/assets/73ab95a2-a6cb-486d-b2e0-0ef3d620a599

## 시야 회전 각도 제한

- 위아래로 회전하며 얼만큼 제한하는 것이 좋을지 각도 확인

```C#
using UnityEngine;

public class CamerRotate : MonoBehaviour
{
    //회전 속도
    public float rotateSpeed;

    // Update is called once per frame
    void Update()
    {
        // 마우스의 위아래 움직임 입력을 숫자로 받아서 저장
        float mouseMoveY = Input.GetAxis("Mouse Y");

        // 마우스가 움직인 만큼 X축 회전   
        // X축 값이 커질수록 아래로 회전 -> 마우스를 위로 움직이면 시야가 아래로 내려감 -> 음수로 설정
        transform.Rotate(-mouseMoveY * rotateSpeed * Time.deltaTime, 0, 0);

        // x축의 각도 조절
        print(transform.rotation.x);
    }
}
```

인스펙터창에 보이는 각도(오일러 각)|콘솔창에 출력된 각도(쿼터니언)
|:---:|:---:|
<img width="96" height="21" alt="스크린샷 2025-10-02 오후 9 53 10" src="https://github.com/user-attachments/assets/be5bcb8b-bf30-4530-8d22-083e9e523a87" />|<img width="289" height="270" alt="스크린샷 2025-10-02 오후 9 52 23" src="https://github.com/user-attachments/assets/770bfd7c-cb3b-4d2a-9d06-cbd15282a739" />

둘의 각도 기준이 다르기 때문에 오일러 각으로 출력하기 위해 수정
- `rotation.x` 대신 `eulerAngles.x` 사용
- 0 ~360도 사이의 값만 처리 가능
  - -10도 == 350도

```C#
using UnityEngine;

public class CamerRotate : MonoBehaviour
{
    //회전 속도
    public float rotateSpeed;

    // Update is called once per frame
    void Update()
    {
        // 마우스의 위아래 움직임 입력을 숫자로 받아서 저장
        float mouseMoveY = Input.GetAxis("Mouse Y");

        // 마우스가 움직인 만큼 X축 회전   
        // X축 값이 커질수록 아래로 회전 -> 마우스를 위로 움직이면 시야가 아래로 내려감 -> 음수로 설정
        transform.Rotate(-mouseMoveY * rotateSpeed * Time.deltaTime, 0, 0);

        // x축의 각도 조절
        print(transform.eulerAngles.x);
    }
}
```

<img width="274" height="261" alt="스크린샷 2025-10-02 오후 9 57 51" src="https://github.com/user-attachments/assets/aad13516-e815-4778-990b-eb46079d5740" />

- `eulerangles` 값을 이용해 위아래 회전 범위를 -30도 ~ 30도로 제한하는 코드 작성

```C#
using UnityEngine;

public class CamerRotate : MonoBehaviour
{
    //회전 속도
    public float rotateSpeed;

    // eulerAngles.x 의 값을 담아둘 변수
    float tempX;

    // Update is called once per frame
    void Update()
    {
        // 마우스의 위아래 움직임 입력을 숫자로 받아서 저장
        float mouseMoveY = Input.GetAxis("Mouse Y");

        // 마우스가 움직인 만큼 X축 회전   
        // X축 값이 커질수록 아래로 회전 -> 마우스를 위로 움직이면 시야가 아래로 내려감 -> 음수로 설정
        transform.Rotate(-mouseMoveY * rotateSpeed * Time.deltaTime, 0, 0);

        // x의 각도가 180을 넘는다면
        if (transform.eulerAngles.x > 180)
        {
            // 360을 빼서 음수로 저장
            tempX = transform.eulerAngles.x - 360;
        }
        // x의 각도가 180을 넘지 않는다면
        else
        {
            // 그대로 저장
            tempX = transform.eulerAngles.x;
        }

        // 음수를 포함한 x의 각도를 -30도 ~ 30도로 제한
        // Mathf.Clamp(제한하려는 값, 최솟값, 최댓값)
        tempX = Mathf.Clamp(tempX, -30, 30);

        // 제한된 값을 eulerAngles.x에 적용
        transform.eulerAngles = new Vector3(tempX, 0, 0);
    }
}
```

#### Main Camera의 인스펙터창의 카메라가 좌우회전시 Y축, Z축이 따라가지 못하고 고정되어 있는 문제 해결

```C#
using UnityEngine;

public class CamerRotate : MonoBehaviour
{
    //회전 속도
    public float rotateSpeed;

    // eulerAngles.x 의 값을 담아둘 변수
    float tempX;

    // Update is called once per frame
    void Update()
    {
        // 마우스의 위아래 움직임 입력을 숫자로 받아서 저장
        float mouseMoveY = Input.GetAxis("Mouse Y");

        // 마우스가 움직인 만큼 X축 회전   
        // X축 값이 커질수록 아래로 회전 -> 마우스를 위로 움직이면 시야가 아래로 내려감 -> 음수로 설정
        transform.Rotate(-mouseMoveY * rotateSpeed * Time.deltaTime, 0, 0);

        // x의 각도가 180을 넘는다면
        if (transform.eulerAngles.x > 180)
        {
            // 360을 빼서 음수로 저장
            tempX = transform.eulerAngles.x - 360;
        }
        // x의 각도가 180을 넘지 않는다면
        else
        {
            // 그대로 저장
            tempX = transform.eulerAngles.x;
        }

        // 음수를 포함한 x의 각도를 -30도 ~ 30도로 제한
        // Mathf.Clamp(제한하려는 값, 최솟값, 최댓값)
        tempX = Mathf.Clamp(tempX, -30, 30);

        // 제한된 값을 eulerAngles.x에 적용 (y축과 z축은 고정되지 않고 현재 각도대로)
        transform.eulerAngles = new Vector3(tempX, transform.eulerAngles.y, transform.eulerAngles.z);
    }
}
```

...? 근데 뭐가 문제인지 모르겠다. 그전이랑 똑같은듯? 예전 버전이라서 업데이트 된건가?


