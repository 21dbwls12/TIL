# 갈때까지 가보는 피보나치 수


### 성능 요약

메모리: 1351 KB, 시간: 1 ms

### 분류

구현

### 제출 일자

2024년 2월 9일 17:29:28

### 문제 설명

<p>이번엔 Quick Sort 를 구현해 봅시다.</p>

### 입력

 <p>50이하의 자연수</p>

### 개념

#### Bubble Sort

 <p>작동 원리</p>  

 1. 정렬되지 않은 배열에서 인덱스 0번, (size - 1)번, (size x 1/2)번을 피봇(pivot, 기준점)으로 선정
 2. 기준과 반대편(가운데 인덱스이면 0번(i)과 (size - 1)번(j) 값을 피봇값을 비교)에서 부터 시작
 3. 만약 배열순으로 피봇값과 순서가 왼쪽에 있어야하면 왼쪽으로, 오른쪽과 있어야하면 오른쪽으로 교차
    ex) 오름차순, 0번 -> 맨 마지막부터 0번의 값과 피봇값보다 크면 다음으로 넘어가고 작으면 i으로 기억하고 다음 값 중 피봇값보다 작은 값중 가장 가까운                         값과 교체
 4. 피봇이 교체될 때까지 반복
 5. 피봇값을 기준으로 왼쪽과 오른쪽에 다시 피봇 선정 후 위 방법 반복하여 모든 값을 정렬

![image](https://github.com/21dbwls12/TIL/assets/139525941/16f46454-2eb1-486c-ae2d-62bbae0d2e26)
![image](https://github.com/21dbwls12/TIL/assets/139525941/b3c01170-570b-435f-aa3f-89a06838befa)
![image](https://github.com/21dbwls12/TIL/assets/139525941/b8c25575-2fa5-4fed-8722-a3b026c0deb5)
![image](https://github.com/21dbwls12/TIL/assets/139525941/9c761e7e-2e5e-487c-9e46-ae70c02d2268)

<p>특징</p>

- 가장 간단하고 쉬운 방식은 항상 맨 오른쪽의 값을 피봇으로 선택하는 방법
- 최선과 평균의 시간 복잡도는 O(nlogN), 최악의 시간 복잡도는 O(n²)
- 공간 복잡도는 O(logN)
